"""
Tool Forge - RAEC creates tools when it needs capabilities

This is how RAEC extends itself:
1. Recognize a capability gap
2. Specify what the tool should do
3. Generate the tool code
4. Test the tool
5. Register it for use
"""

import json
import hashlib
import sqlite3
from dataclasses import dataclass, asdict, field
from datetime import datetime
from pathlib import Path
from typing import List, Optional, Dict, Any, Callable
from enum import Enum
import importlib.util
import sys
import traceback


class ToolStatus(Enum):
    """Tool lifecycle states"""
    DRAFT = "draft"           # Just generated, not tested
    TESTING = "testing"       # Being tested
    VERIFIED = "verified"     # Passed tests, ready for use
    DEPLOYED = "deployed"     # In active use
    DEPRECATED = "deprecated" # Replaced or obsolete
    FAILED = "failed"         # Didn't pass verification


@dataclass
class ToolSpec:
    """Specification for a tool to be generated"""
    name: str
    description: str
    purpose: str  # Why does RAEC need this?
    inputs: Dict[str, str]  # Parameter name -> description
    output: str  # What it returns
    examples: List[Dict[str, Any]]  # Example inputs/outputs
    constraints: List[str]  # Safety/behavior constraints


@dataclass
class GeneratedTool:
    """A tool generated by RAEC"""
    id: Optional[int]
    name: str
    description: str
    version: int
    status: str

    # The tool itself
    code: str  # Python code
    function_name: str
    signature: str  # Function signature

    # Metadata
    spec: Dict  # Original specification
    created_at: str
    updated_at: str
    created_by: str  # What triggered creation

    # Tracking
    test_results: List[Dict]
    usage_count: int
    success_count: int
    last_used: Optional[str]

    # Lineage
    parent_id: Optional[int]  # If this is a revision
    revision_reason: Optional[str]

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_row(cls, row: tuple) -> 'GeneratedTool':
        return cls(
            id=row[0],
            name=row[1],
            description=row[2],
            version=row[3],
            status=row[4],
            code=row[5],
            function_name=row[6],
            signature=row[7],
            spec=json.loads(row[8]) if row[8] else {},
            created_at=row[9],
            updated_at=row[10],
            created_by=row[11],
            test_results=json.loads(row[12]) if row[12] else [],
            usage_count=row[13],
            success_count=row[14],
            last_used=row[15],
            parent_id=row[16],
            revision_reason=row[17]
        )

    @property
    def success_rate(self) -> float:
        if self.usage_count == 0:
            return 0.0
        return self.success_count / self.usage_count


class ToolForge:
    """
    Creates, tests, and manages dynamically generated tools.

    When RAEC encounters a task requiring capabilities it lacks,
    ToolForge can generate a new tool to fill the gap.
    """

    def __init__(
        self,
        db_path: Optional[Path] = None,
        tools_dir: Optional[Path] = None,
        llm_interface: Any = None
    ):
        if db_path is None:
            db_path = Path(__file__).parent.parent / "data" / "toolsmith.db"
        if tools_dir is None:
            tools_dir = Path(__file__).parent.parent / "tools" / "generated"

        self.db_path = db_path
        self.tools_dir = tools_dir
        self.llm = llm_interface

        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self.tools_dir.mkdir(parents=True, exist_ok=True)

        self._init_db()
        self._loaded_tools: Dict[str, Callable] = {}

    def _init_db(self):
        """Initialize the toolsmith database"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute("""
                CREATE TABLE IF NOT EXISTS tools (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    name TEXT NOT NULL,
                    description TEXT NOT NULL,
                    version INTEGER NOT NULL DEFAULT 1,
                    status TEXT NOT NULL DEFAULT 'draft',
                    code TEXT NOT NULL,
                    function_name TEXT NOT NULL,
                    signature TEXT NOT NULL,
                    spec TEXT,
                    created_at TEXT NOT NULL,
                    updated_at TEXT NOT NULL,
                    created_by TEXT NOT NULL,
                    test_results TEXT,
                    usage_count INTEGER NOT NULL DEFAULT 0,
                    success_count INTEGER NOT NULL DEFAULT 0,
                    last_used TEXT,
                    parent_id INTEGER,
                    revision_reason TEXT,
                    UNIQUE(name, version)
                )
            """)

            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_tools_name
                ON tools(name)
            """)
            conn.execute("""
                CREATE INDEX IF NOT EXISTS idx_tools_status
                ON tools(status)
            """)
            conn.commit()

    def identify_gap(self, task: str, available_tools: List[str]) -> Optional[ToolSpec]:
        """
        Identify if a task requires a capability we don't have.

        Returns a ToolSpec if a new tool is needed, None if existing tools suffice.
        """
        if not self.llm:
            return None

        tools_list = ", ".join(available_tools) if available_tools else "None"

        prompt = f"""Analyze if this task requires a capability not covered by available tools.

Task: {task}

Available tools: {tools_list}

If a new tool is needed, respond with:
NEED_TOOL: true
NAME: [tool_name in snake_case]
DESCRIPTION: [what it does]
PURPOSE: [why it's needed for this task]
INPUTS: [comma-separated list of input_name:description pairs]
OUTPUT: [what it returns]
CONSTRAINTS: [safety/behavior constraints, comma-separated]

If existing tools can handle this, respond with:
NEED_TOOL: false"""

        response = self.llm.generate(prompt, temperature=0.3, max_tokens=400)

        if "NEED_TOOL: false" in response:
            return None

        try:
            lines = response.strip().split('\n')
            parsed = {}

            for line in lines:
                if ':' in line:
                    key, val = line.split(':', 1)
                    parsed[key.strip().upper()] = val.strip()

            if parsed.get('NEED_TOOL', '').lower() != 'true':
                return None

            # Parse inputs
            inputs = {}
            if parsed.get('INPUTS'):
                for inp in parsed['INPUTS'].split(','):
                    if ':' in inp:
                        name, desc = inp.strip().split(':', 1)
                        inputs[name.strip()] = desc.strip()

            # Parse constraints
            constraints = []
            if parsed.get('CONSTRAINTS'):
                constraints = [c.strip() for c in parsed['CONSTRAINTS'].split(',')]

            return ToolSpec(
                name=parsed.get('NAME', 'unknown_tool'),
                description=parsed.get('DESCRIPTION', ''),
                purpose=parsed.get('PURPOSE', ''),
                inputs=inputs,
                output=parsed.get('OUTPUT', 'Any'),
                examples=[],
                constraints=constraints
            )
        except Exception:
            return None

    def generate_tool(self, spec: ToolSpec, created_by: str = "auto") -> GeneratedTool:
        """
        Generate a tool from a specification.
        """
        if not self.llm:
            raise ValueError("LLM interface required for tool generation")

        # Build prompt
        inputs_desc = "\n".join([f"  - {k}: {v}" for k, v in spec.inputs.items()])
        constraints_desc = "\n".join([f"  - {c}" for c in spec.constraints])

        prompt = f"""Generate a Python function for this tool specification.

Name: {spec.name}
Description: {spec.description}
Purpose: {spec.purpose}

Inputs:
{inputs_desc}

Output: {spec.output}

Constraints:
{constraints_desc}

Requirements:
1. Function should be self-contained (no external dependencies beyond stdlib)
2. Include comprehensive error handling
3. Include a docstring
4. Return meaningful results or raise clear exceptions
5. Be safe - validate inputs, don't allow dangerous operations

Respond with ONLY the Python code, no markdown formatting or explanation.
Start with 'def {spec.name}('"""

        code = self.llm.generate(prompt, temperature=0.2, max_tokens=1000)

        # Clean up code
        code = code.strip()
        if code.startswith("```"):
            code = code.split('\n', 1)[1]
        if code.endswith("```"):
            code = code.rsplit('\n', 1)[0]
        code = code.strip()

        # Ensure function name matches
        if not code.startswith(f"def {spec.name}("):
            # Try to find and extract the function
            if f"def {spec.name}(" in code:
                idx = code.index(f"def {spec.name}(")
                code = code[idx:]

        # Extract signature
        first_line = code.split('\n')[0]
        signature = first_line.replace('def ', '').rstrip(':')

        now = datetime.now().isoformat()

        tool = GeneratedTool(
            id=None,
            name=spec.name,
            description=spec.description,
            version=1,
            status=ToolStatus.DRAFT.value,
            code=code,
            function_name=spec.name,
            signature=signature,
            spec=asdict(spec),
            created_at=now,
            updated_at=now,
            created_by=created_by,
            test_results=[],
            usage_count=0,
            success_count=0,
            last_used=None,
            parent_id=None,
            revision_reason=None
        )

        # Check for existing versions
        existing = self._get_latest_version(spec.name)
        if existing:
            tool.version = existing.version + 1
            tool.parent_id = existing.id

        # Save to database
        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute("""
                INSERT INTO tools
                (name, description, version, status, code, function_name, signature,
                 spec, created_at, updated_at, created_by, test_results, usage_count,
                 success_count, last_used, parent_id, revision_reason)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                tool.name, tool.description, tool.version, tool.status,
                tool.code, tool.function_name, tool.signature,
                json.dumps(tool.spec), tool.created_at, tool.updated_at,
                tool.created_by, json.dumps(tool.test_results),
                tool.usage_count, tool.success_count, tool.last_used,
                tool.parent_id, tool.revision_reason
            ))
            tool.id = cursor.lastrowid
            conn.commit()

        # Save code to file
        self._save_tool_file(tool)

        return tool

    def _save_tool_file(self, tool: GeneratedTool):
        """Save tool code to a file"""
        file_path = self.tools_dir / f"{tool.name}_v{tool.version}.py"
        with open(file_path, 'w') as f:
            f.write(f'"""\nGenerated Tool: {tool.name} v{tool.version}\n')
            f.write(f'Description: {tool.description}\n')
            f.write(f'Created: {tool.created_at}\n"""\n\n')
            f.write(tool.code)

    def test_tool(self, tool_id: int, test_cases: List[Dict[str, Any]] = None) -> bool:
        """
        Test a generated tool.

        Returns True if all tests pass.
        """
        tool = self.get_tool(tool_id)
        if not tool:
            return False

        # Update status
        self._update_status(tool_id, ToolStatus.TESTING)

        # Load the tool
        try:
            func = self._load_tool_function(tool)
        except Exception as e:
            self._record_test_result(tool_id, {
                "type": "load_error",
                "error": str(e),
                "passed": False
            })
            self._update_status(tool_id, ToolStatus.FAILED)
            return False

        # Run test cases
        all_passed = True
        results = []

        # If no test cases provided, generate basic ones
        if not test_cases and self.llm:
            test_cases = self._generate_test_cases(tool)

        for tc in (test_cases or []):
            try:
                result = func(**tc.get('inputs', {}))
                passed = True

                # Check expected output if provided
                if 'expected' in tc:
                    passed = result == tc['expected']

                results.append({
                    "inputs": tc.get('inputs'),
                    "expected": tc.get('expected'),
                    "actual": str(result)[:200],
                    "passed": passed
                })

                if not passed:
                    all_passed = False

            except Exception as e:
                results.append({
                    "inputs": tc.get('inputs'),
                    "error": str(e),
                    "passed": False
                })
                all_passed = False

        # Record results
        for r in results:
            self._record_test_result(tool_id, r)

        # Update status
        new_status = ToolStatus.VERIFIED if all_passed else ToolStatus.FAILED
        self._update_status(tool_id, new_status)

        return all_passed

    def _generate_test_cases(self, tool: GeneratedTool) -> List[Dict]:
        """Generate test cases using LLM"""
        prompt = f"""Generate 3 test cases for this function:

{tool.code}

For each test case, provide:
- inputs: dict of parameter names to values
- expected: expected return value (if deterministic)

Respond with JSON array format:
[{{"inputs": {{"param": "value"}}, "expected": "result"}}]"""

        response = self.llm.generate(prompt, temperature=0.3, max_tokens=300)

        try:
            # Extract JSON
            if '[' in response:
                start = response.index('[')
                end = response.rindex(']') + 1
                return json.loads(response[start:end])
        except:
            pass

        return []

    def _load_tool_function(self, tool: GeneratedTool) -> Callable:
        """Load a tool's function into memory"""
        if tool.name in self._loaded_tools:
            return self._loaded_tools[tool.name]

        # Create module from code
        module_name = f"generated_tool_{tool.name}"
        spec = importlib.util.spec_from_loader(module_name, loader=None)
        module = importlib.util.module_from_spec(spec)

        exec(tool.code, module.__dict__)

        func = getattr(module, tool.function_name)
        self._loaded_tools[tool.name] = func

        return func

    def _record_test_result(self, tool_id: int, result: Dict):
        """Record a test result"""
        with sqlite3.connect(self.db_path) as conn:
            row = conn.execute(
                "SELECT test_results FROM tools WHERE id = ?",
                (tool_id,)
            ).fetchone()

            results = json.loads(row[0]) if row and row[0] else []
            results.append({**result, "timestamp": datetime.now().isoformat()})

            conn.execute(
                "UPDATE tools SET test_results = ?, updated_at = ? WHERE id = ?",
                (json.dumps(results), datetime.now().isoformat(), tool_id)
            )
            conn.commit()

    def _update_status(self, tool_id: int, status: ToolStatus):
        """Update tool status"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                "UPDATE tools SET status = ?, updated_at = ? WHERE id = ?",
                (status.value, datetime.now().isoformat(), tool_id)
            )
            conn.commit()

    def deploy_tool(self, tool_id: int) -> bool:
        """Mark a tool as deployed (ready for production use)"""
        tool = self.get_tool(tool_id)
        if not tool or tool.status != ToolStatus.VERIFIED.value:
            return False

        self._update_status(tool_id, ToolStatus.DEPLOYED)
        return True

    def use_tool(self, name: str, **kwargs) -> Any:
        """Use a deployed tool"""
        tool = self._get_latest_deployed(name)
        if not tool:
            raise ValueError(f"No deployed tool named '{name}'")

        func = self._load_tool_function(tool)

        try:
            result = func(**kwargs)

            # Track usage
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    UPDATE tools
                    SET usage_count = usage_count + 1,
                        success_count = success_count + 1,
                        last_used = ?
                    WHERE id = ?
                """, (datetime.now().isoformat(), tool.id))
                conn.commit()

            return result

        except Exception as e:
            # Track failure
            with sqlite3.connect(self.db_path) as conn:
                conn.execute("""
                    UPDATE tools
                    SET usage_count = usage_count + 1,
                        last_used = ?
                    WHERE id = ?
                """, (datetime.now().isoformat(), tool.id))
                conn.commit()

            raise

    def get_tool(self, tool_id: int) -> Optional[GeneratedTool]:
        """Get a tool by ID"""
        with sqlite3.connect(self.db_path) as conn:
            row = conn.execute(
                "SELECT * FROM tools WHERE id = ?",
                (tool_id,)
            ).fetchone()

            return GeneratedTool.from_row(row) if row else None

    def _get_latest_version(self, name: str) -> Optional[GeneratedTool]:
        """Get the latest version of a tool"""
        with sqlite3.connect(self.db_path) as conn:
            row = conn.execute("""
                SELECT * FROM tools
                WHERE name = ?
                ORDER BY version DESC
                LIMIT 1
            """, (name,)).fetchone()

            return GeneratedTool.from_row(row) if row else None

    def _get_latest_deployed(self, name: str) -> Optional[GeneratedTool]:
        """Get the latest deployed version of a tool"""
        with sqlite3.connect(self.db_path) as conn:
            row = conn.execute("""
                SELECT * FROM tools
                WHERE name = ? AND status = 'deployed'
                ORDER BY version DESC
                LIMIT 1
            """, (name,)).fetchone()

            return GeneratedTool.from_row(row) if row else None

    def list_tools(self, status: Optional[ToolStatus] = None) -> List[GeneratedTool]:
        """List tools, optionally filtered by status"""
        with sqlite3.connect(self.db_path) as conn:
            if status:
                rows = conn.execute("""
                    SELECT * FROM tools WHERE status = ?
                    ORDER BY name, version DESC
                """, (status.value,)).fetchall()
            else:
                rows = conn.execute("""
                    SELECT * FROM tools ORDER BY name, version DESC
                """).fetchall()

            return [GeneratedTool.from_row(row) for row in rows]

    def get_stats(self) -> dict:
        """Get toolsmith statistics"""
        with sqlite3.connect(self.db_path) as conn:
            total = conn.execute("SELECT COUNT(*) FROM tools").fetchone()[0]
            deployed = conn.execute(
                "SELECT COUNT(*) FROM tools WHERE status = 'deployed'"
            ).fetchone()[0]
            total_usage = conn.execute(
                "SELECT SUM(usage_count) FROM tools"
            ).fetchone()[0] or 0
            total_success = conn.execute(
                "SELECT SUM(success_count) FROM tools"
            ).fetchone()[0] or 0

            return {
                "total_tools": total,
                "deployed": deployed,
                "total_usage": total_usage,
                "overall_success_rate": total_success / total_usage if total_usage > 0 else 0.0
            }

    def format_tools(self) -> str:
        """Format tools for display"""
        tools = self.list_tools()
        if not tools:
            return "No generated tools."

        lines = [f"Generated Tools ({len(tools)}):", "=" * 40]

        # Group by name
        by_name = {}
        for t in tools:
            if t.name not in by_name:
                by_name[t.name] = []
            by_name[t.name].append(t)

        for name, versions in by_name.items():
            latest = versions[0]
            lines.append(f"\n{name} (v{latest.version})")
            lines.append(f"  Status: {latest.status}")
            lines.append(f"  Description: {latest.description[:50]}...")
            lines.append(f"  Usage: {latest.usage_count} ({latest.success_rate:.0%} success)")

        return "\n".join(lines)
